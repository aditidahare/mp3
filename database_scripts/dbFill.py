#!/usr/bin/env python3

import sys
import getopt
import http.client
import json
from random import choice, randint
from datetime import date
from time import mktime


def usage():
    print('dbFill.py -u <baseurl> -p <port> -n <numUsers> -t <numTasks>')


def make_conn(baseurl, port):
    # HTTPS for hosted, HTTP for localhost
    if baseurl != "localhost":
        return http.client.HTTPSConnection(baseurl, timeout=30)
    return http.client.HTTPConnection(baseurl, port, timeout=30)


def send_request(method, url, body, baseurl, port, headers):
    conn = make_conn(baseurl, port)
    conn.request(method, url, body, headers)
    resp = conn.getresponse()
    status = resp.status
    raw = resp.read()
    conn.close()
    try:
        data = json.loads(raw or "{}")
    except Exception:
        data = {"message": f"Non-JSON response (status {status})", "raw": raw.decode("utf-8", "ignore")}
    return status, data


def main(argv):
    baseurl = "localhost"
    port = 3000
    userCount = 20
    taskCount = 100

    try:
        opts, _ = getopt.getopt(argv, "hu:p:n:t:", ["url=", "port=", "users=", "tasks="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt == "-h":
            usage()
            sys.exit()
        elif opt in ("-u", "--url"):
            baseurl = arg.replace("https://", "").replace("http://", "").strip("/")
        elif opt in ("-p", "--port"):
            port = int(arg)
        elif opt in ("-n", "--users"):
            userCount = int(arg)
        elif opt in ("-t", "--tasks"):
            taskCount = int(arg)

    headers = {"Content-type": "application/json", "Accept": "application/json"}

    first = ["james","john","robert","michael","william","david","richard","charles","joseph","thomas"]
    last  = ["smith","johnson","williams","jones","brown","davis","miller","wilson","moore","taylor"]

    userIDs, userNames = [], []

    print("ðŸ‘¤ Creating users...")
    i = 0
    attempts = 0
    # keep going until we actually have `userCount` saved
    while i < userCount:
        attempts += 1
        fname = choice(first)
        lname = choice(last)
        # unique email: add counter + random
        email = f"{fname}.{lname}.{i}.{randint(10000,99999)}@example.com"
        body = json.dumps({"name": f"{fname} {lname}", "email": email})

        status, resp = send_request("POST", "/api/users", body, baseurl, port, headers)
        data = resp.get("data")

        if status in (200, 201) and isinstance(data, dict) and data.get("_id"):
            userIDs.append(str(data["_id"]))
            userNames.append(str(data["name"]))
            i += 1
        else:
            # Show what happened and retry with a fresh email
            msg = resp.get("message", f"HTTP {status}")
            # print once in a while to not spam
            print(f"  retry user {i}: {msg}")

        # very defensive break to avoid infinite loop (shouldn't hit)
        if attempts > userCount * 20:
            raise RuntimeError("Too many retries creating users; check API logs.")

    print(f"âœ… Users created: {len(userIDs)}")

    # read task names
    with open("tasks.txt", "r", encoding="utf-8") as f:
        taskNames = [line.strip() for line in f if line.strip()]

    print("ðŸ“ Creating tasks...")
    created = 0
    for _ in range(taskCount):
        assigned = (randint(0, 10) > 4)
        idx = randint(0, len(userIDs) - 1) if assigned else None

        # deadline in ms since epoch (int)
        deadline = int((mktime(date.today().timetuple()) + randint(86400, 864000)) * 1000)

        task = {
            "name": choice(taskNames),
            "deadline": deadline,
            "completed": bool(randint(0, 1)),
            "assignedUser": userIDs[idx] if assigned else "",
            "assignedUserName": userNames[idx] if assigned else "unassigned",
            "description": "Autogenerated task."
        }

        status, resp = send_request("POST", "/api/tasks", json.dumps(task), baseurl, port, headers)
        if status in (200, 201) and isinstance(resp.get("data"), dict):
            created += 1
        else:
            # soft-fail task creates; continue
            pass

    print(f"ðŸŽ‰ DONE â†’ {len(userIDs)} users + {created} tasks added to {baseurl}")


if __name__ == "__main__":
    main(sys.argv[1:])
